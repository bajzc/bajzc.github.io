[{"categories":["Review"],"content":" Contents Part I - Basic Before All... Choice of Operating System About File System How to install Linux Part II - Network Part III - Docker Docker Network: Frpc Nginx Proxy manager Nextcloud Docker Compose Part IV - Finish? Part I - Basic Before All... What is a home NAS? A typical home NAS is used for storing and sharing photos and files. As an extension to traditional NAS, the server config followed by this article would include more applications like offline downloader, media server, and printer server... Hardware requirement: Any kind of popular architecture (x86, amd64, arm64) CPU, with high-speed network (ethernet, WIFI) and disk (USB3.*, SATA, NVME) interface. I'm not going to stop you from using an Android phone with a type-C to 4*USB (with PD backwards charging) as your cherished server. Because technically I used such a server for more than 6 months, a Raspberry Pi 4. I had developed a habit to reboot it regularly every 2 days and bear the risk of losing all data. So, be kind to yourself at this stage. Power and noise worth be considered as part of the budget, and also extension capability. This is my current hardware, just for reference: cpu: Intel(R) Celeron(R) N5105 @ 2.00GHz, 2800 MHz graphics card: Intel JasperLake [UHD Graphics] disk: /dev/nvme0n1 KIOXIA NVMe SSD # root disk /dev/sda TOSHIBA MG08ADA8 # data disk memory: Memory Size: 15 GB Choice of Operating System Linux Not a nerd? Go for Synology NAS About File System I'm currently using btrfs, which is a native Linux file system that has lots of modern features attracts me: CoW (copy on write): File won't be overwritten partially and then broken after a sudden power outage Compression: save your disk and money Subvolume and snapshot: save your data from accident such as you deleted your system (you won't, right?) How to install Linux I believe there are thousands of tutorials for beginners. Join the Arch \"cult\" I don't trust any binary distro, I want to compile everything, where should I start? I just want a normal and stable one Part II - Network /images/NAS-network.svg Network structure As far as I know, many ISPs (Internet Service Provider) block Port 80 and 443, which basically means you can not access directly to the web page. There are many workarounds: use another port instead and specify it when you access; use IPv6 instead but 80 and 443 may still be blocked; use a reverse proxy server but with higher delay. I'm using frp as my reverse proxy software. A reverse proxy server means all your data will pass through a server held by others, so for those highly concerned about security, check out my previous post here Frpc (client side) listens to a server at a specific port, your DNS record should point to that server. Once a request is made, the server will pass it to you according to the domain name, then frpc will forward it to the right application. To be clear, frpc is still an application behind the firewall and inside docker. So if you are using IPv4 only, you can block all ports other than the one frpc is using. (only TCP) Here is my frpc config file: [common] server_addr = frp2.freefrp.net # proxy server you are using server_port = 7000 # port given by the server holder, default: 7000 token = freefrp.net # password, here the server is for public: https://freefrp.net/ [ipv4_bajzc_com_http] # a unique entity type = http # proxy type local_ip = 10.5.0.3 # local server address local_port = 80 # local server port custom_domains = ipv4.bajzc.com # URL you use to access this application [ipv4_bajzc_com_https] type = https local_ip = 10.5.0.3 local_port = 443 custom_domains = ipv4.bajzc.com ...... A single frpc cannot stand, you need a frps (server) and correct DNS records. A frp server could be a VPS you buy from big cloud computing company, or from \"kind\" people share their resources. (Again, people concerned about security should check out my previous post here) My DNS records as reference: DNS-records Note 2024.2.11 Update: I switched to use cloudf","date":"2024-02-03","objectID":"/posts/home-nas-deployment/:0:0","tags":["NAS","docker","linux"],"title":"Home NAS deploment","uri":"/posts/home-nas-deployment/"},{"categories":["Review"],"content":" Note My domain is provided from Google, the method of getting the API token could be different for other provider Contents Get certificates Apache Config Get certificates emerge -a app-crypt/acme-sh emerge --ask dcron, acme-sh need this to set cron job to renew the certs automatically Get your domain access token from the provider (Google Domain) For Google Domains: export GOOGLEDOMAINS_ACCESS_TOKEN=\"\u003cgenerated-access-token\u003e\" run acme-sh as root acme.sh --issue --dns dns_googledomains -d bajzc.com -d ipv4.bajzc.com -k ec-384 --ecc Log: [Sat Nov 11 13:58:34 CST 2023] Using CA: https://acme.zerossl.com/v2/DV90 [Sat Nov 11 13:58:34 CST 2023] Creating domain key [Sat Nov 11 13:58:34 CST 2023] The domain key is here: /etc/acme-sh//bajzc.com_ecc/bajzc.com.key [Sat Nov 11 13:58:34 CST 2023] Multi domain='DNS:bajzc.com,DNS:ipv4.bajzc.com' [Sat Nov 11 13:58:34 CST 2023] Getting domain auth token for each domain [Sat Nov 11 13:58:42 CST 2023] Getting webroot for domain='bajzc.com' [Sat Nov 11 13:58:42 CST 2023] Getting webroot for domain='ipv4.bajzc.com' [Sat Nov 11 13:58:43 CST 2023] Adding txt value: eegpTUjIL53Nvy0ES6sS-W3LZA4vVBfQQ for domain: _acme-challenge.bajzc.com [Sat Nov 11 13:58:43 CST 2023] Invoking Google Domains ACME DNS API. [Sat Nov 11 13:58:44 CST 2023] Adding TXT record for _acme-challenge.bajzc.com. [Sat Nov 11 13:58:47 CST 2023] TXT record added. [Sat Nov 11 13:58:47 CST 2023] The txt record is added: Success. [Sat Nov 11 13:58:47 CST 2023] Adding txt value: .. for domain: _acme-challenge.ipv4.bajzc.com [Sat Nov 11 13:58:47 CST 2023] Invoking Google Domains ACME DNS API. [Sat Nov 11 13:58:50 CST 2023] Adding TXT record for _acme-challenge.ipv4.bajzc.com. [Sat Nov 11 13:58:52 CST 2023] TXT record added. [Sat Nov 11 13:58:52 CST 2023] The txt record is added: Success. [Sat Nov 11 13:58:52 CST 2023] Let's check each DNS record now. Sleep 20 seconds first. [Sat Nov 11 13:59:13 CST 2023] You can use '--dnssleep' to disable public dns checks. [Sat Nov 11 13:59:13 CST 2023] See: https://github.com/acmesh-official/acme.sh/wiki/dnscheck [Sat Nov 11 13:59:14 CST 2023] Checking bajzc.com for _acme-challenge.bajzc.com [Sat Nov 11 13:59:14 CST 2023] Domain bajzc.com '_acme-challenge.bajzc.com' success. [Sat Nov 11 13:59:14 CST 2023] Checking ipv4.bajzc.com for _acme-challenge.ipv4.bajzc.com [Sat Nov 11 13:59:15 CST 2023] Domain ipv4.bajzc.com '_acme-challenge.ipv4.bajzc.com' success. [Sat Nov 11 13:59:15 CST 2023] All success, let's return [Sat Nov 11 13:59:15 CST 2023] Verifying: bajzc.com [Sat Nov 11 13:59:17 CST 2023] Processing, The CA is processing your order, please just wait. (1/30) [Sat Nov 11 13:59:22 CST 2023] Success [Sat Nov 11 13:59:22 CST 2023] Verifying: ipv4.bajzc.com [Sat Nov 11 13:59:24 CST 2023] Processing, The CA is processing your order, please just wait. (1/30) [Sat Nov 11 13:59:28 CST 2023] Success [Sat Nov 11 13:59:28 CST 2023] Removing DNS records. [Sat Nov 11 13:59:28 CST 2023] Removing txt: eegpTUjIL53Nvy0ES6sS-W3LZA4vVBfQQ for domain: _acme-challenge.bajzc.com [Sat Nov 11 13:59:28 CST 2023] Invoking Google Domains ACME DNS API. [Sat Nov 11 13:59:30 CST 2023] Removing TXT record for _acme-challenge.bajzc.com. [Sat Nov 11 13:59:32 CST 2023] TXT record removed. [Sat Nov 11 13:59:32 CST 2023] Removed: Success [Sat Nov 11 13:59:32 CST 2023] Removing txt: .. for domain: _acme-challenge.ipv4.bajzc.com [Sat Nov 11 13:59:32 CST 2023] Invoking Google Domains ACME DNS API. [Sat Nov 11 13:59:36 CST 2023] Removing TXT record for _acme-challenge.ipv4.bajzc.com. [Sat Nov 11 13:59:38 CST 2023] TXT record removed. [Sat Nov 11 13:59:38 CST 2023] Removed: Success [Sat Nov 11 13:59:38 CST 2023] Verify finished, start to sign. [Sat Nov 11 13:59:38 CST 2023] Lets finalize the order. [Sat Nov 11 13:59:38 CST 2023] Le_OrderFinalize='https://acme.zerossl.com/v2/DV90/order/BFZaIPs9kuec-R1zsU1Cqw/finalize' [Sat Nov 11 13:59:40 CST 2023] Order status is processing, lets sleep and retry. [Sat Nov 11 13:59:40 CST 2023] Retry afte","date":"2023-11-11","objectID":"/posts/lets-encrypt-gentoo/:0:0","tags":["SSL","acme","Gentoo"],"title":"Let's encrypt! (Gentoo)","uri":"/posts/lets-encrypt-gentoo/"},{"categories":["Review"],"content":" Contents NVME support in kernel was not set as it should be: SYSV or INIT error And finally, after 3 days struggling: Here are some problems you may find even if you follow the LFS (Linux From Scratch) book LINE BY LINE: Use Google wisely, you will find the solution! NVME support in kernel was not set as it should be: Device Drivers-\u003eNVME Support SYSV or INIT error And finally, after 3 days struggling: Note If you are not an expert on *nix, start from other Linux distributions but not LFS. Based on the system you already installed, you can easily(?) try (retry) to build your system. Arch (Manjaro) or Gentoo (liveCD?) can be a good start, but they can be nasty on some particular hardware (graphics cards and wireless NIC) Some tips: kernel config file and grub config, can be copy from or generated by the host system. The purpose of building LFS for me is to have an in-depth understanding of the Linux development toolchain (gcc glibc libs auto*), the configuration of some important software(ssh init grub) and kernel, and the use of the bash environment(sed echo bc). ","date":"2023-09-02","objectID":"/posts/lfs-gg/:0:0","tags":["Linux"],"title":"LFS? GG!","uri":"/posts/lfs-gg/"},{"categories":["Review"],"content":" VLC: how to generate .m3u playlists Contents VLC: how to generate .m3u playlists 1 Syntax of .m3u 2 My file system 3 Script 4 Summary Note The new C language version can be found here: (30.12.2023 update) It's 6x faster than the bash script (1:52/11:08) VLC is a free and open-source media player, and it is PORTABLE and CROSS-PLATFORM. In order to have a better user experience, without paying a penny, it is the best choice. \"M3U (MP3 URL or Moving Picture Experts Group Audio Layer 3 Uniform Resource Locator in full) is a computer file format for a multimedia playlist. One common use of the M3U file format is creating a single-entry playlist file pointing to a stream on the Internet. The created file provides easy access to that stream and is often used in downloads from a website, for emailing, and for listening to Internet radio.\" —Wikipedia As .m3u is one of the playlist format that VLC supports, and its format can be easily followed by a shell script, I chose it to make a list of all my Internet media files. 1 Syntax of .m3u An .m3u file is a plain text file that specifies the locations of one or more media files. Each entry carries one specification, which can be: an absolute local path:C:\\Music\\I_love_this_one.mp3 a relative path: This_one_as_well.mp4 an URL: www.music.com/123.mkv The extended .m3u syntax we will use in the script: 1. #EXTM3U: file header, should be the first line 2. #EXTINF: track information: #EXTINF:123,Title All the syntax for .m3u can be checked on Wikipedia. 2 My file system tree Music -L 1 Music/ ├── Dr._Dre │ ├── 02 - Deep Cover.flac │ ├── ... ├── Imagine_Dragons ├── LOL_BGM ├── OneRepublic ├── The_Fat_Rat └── The_Music_of_Grand_Theft_Auto_V And all those files are published on the Internet, so they can be accessed by http://ipv4.bajzc.com:81/Music/... (use port 81 as the NSP blocked the default port: 80) 3 Script Note This script might fit for me, you can modify it by following the explanation for each function. #! /bin/bash set -e export ListPath=/var/www/html/PlayLists Backup(){ cd $ListPath for name in $(ls -c) do mv $name ./.$name.bak done } ListMovie(){ cd $ListPath/../ echo \"#EXTM3U\" \u003e\u003e $ListPath/ALL.m3u find Movie/ -mindepth 1 -maxdepth 2 | while read line do if [ -d \"$line\" ]; then echo -n \"#EXTGRP \" \u003e\u003e $ListPath/ALL.m3u echo $(echo \"$line\" | sed -e \"s/\\([[:print:]]*\\/\\)*//g\") \u003e\u003e $ListPath/ALL.m3u else duration=$(ffmpeg -i \"$line\" 2\u003e\u00261 | grep \"Duration\"| cut -d ' ' -f 4 | sed s/,// | sed 's@\\..*@@g' | awk '{ split($1, A, \":\"); split(A[3], B, \".\"); print 3600*A[1] + 60*A[2] + B[1] }') if [ \"$duration\" == \"0\" ] || [ \"$duration\" == \"\" ]; then printf \"$line is not a media file, duration: $duration\\n\" continue fi echo -n \"#EXTINF:$duration,\" \u003e\u003e $ListPath/ALL.m3u echo $(echo \"$line\" | sed -e \"s/\\([[:print:]]*\\/\\)*//g\") \u003e\u003e $ListPath/ALL.m3u echo $(echo \"$line\" | sed -e 's/^/http:\\/\\/ipv4.bajzc.com:81\\//') \u003e\u003e $ListPath/ALL.m3u echo \u003e\u003e $ListPath/ALL.m3u fi done } ListAlbum(){ cd /var/www/html/ find Music/ -maxdepth 1 -mindepth 1 -type d | while read line do Album=$(echo \"$line\" | sed -e \"s/\\([[:print:]]*\\/\\)*//g\") echo $Album echo \"#EXTM3U\" \u003e $ListPath/$Album.m3u echo \"#EXTGRP\" \u003e\u003e $ListPath/$Album.m3u echo \"#EXTGRP\" \u003e\u003e $ListPath/ALL.m3u find $line -type f | while read path do duration=$(ffmpeg -i \"$path\" 2\u003e\u00261 | grep \"Duration\"| cut -d ' ' -f 4 | sed s/,// | sed 's@\\..*@@g' | awk '{ split($1, A, \":\"); split(A[3], B, \".\"); print 3600*A[1] + 60*A[2] + B[1] }') if [ \"$duration\" == \"0\" ] || [ \"$duration\" == \"\" ]; then printf \"$path is not a media file, duration: $duration\\n\" continue fi header=\"#EXTINF:$duration,$(echo \"$path\" | sed -e \"s/\\([[:print:]]*\\/\\)*//g\")\" url=\"$(echo \"$path\" | sed -e 's/^/http:\\/\\/ipv4.bajzc.com:81\\//')\" printf \"$header\\n$url\\n\\n\" \u003e\u003e $ListPath/$Album.m3u printf \"$header\\n$url\\n\\n\" \u003e\u003e $ListPath/ALL.m3u done done } compress(){ cd $ListPath tar -czvf PlayList.tar.gz *.m3u zip -qr PlayList.zip *.m3u } Backup ListMovie ListAlbum compress unset ListPath Note You may need to install ","date":"2023-08-12","objectID":"/posts/vlc-how-to-generate-m3u-playlists/:0:0","tags":["VLC"],"title":"VLC: how to generate .m3u playlists","uri":"/posts/vlc-how-to-generate-m3u-playlists/"},{"categories":["Review"],"content":" Note The environment we are in: Linux gentoo 6.5.0-rc1 Contents 1. How to use it? 2. Problem 3. Use cachestat() to solve it 4. Summary If you want to try those demos below, you need to know: generate random files for test #signle random file \"a\" dd if=/dev/urandom of=a bs=1M count=128 # random files \"f1\"-\"f8\" for i in {1..8} do dd if=/dev/urandom of=f${i} bs=1M count=128 done clean all the cache: # echo 3 \u003e /proc/sys/vm/drop_caches Warning The cache must be cleared every time before running the test program, if you want to get accurate results. Because, when the file is generated, it has actually been written to the cache! after running any demo once, there may be cache remaining limit memory: For most systemd users, limit your memory to 1G can be done by: # echo 1073741824 \u003e /sys/fs/cgroup/user.slice/memory.max Caution! To remove the memory limit, DO NOT rewrite the file into empty or 0, Instead, rewrite it into max: # echo max \u003e /sys/fs/cgroup/user.slice/memory.max Note Since Glibc does not yet support the latest sys_call(), here we first borrow the functions in the kernel to implement: Install the header files from Kernel, refer to here # run as root cd /usr/src/linux-6.5-rc1 #where the kernel source is make headers_install ARCH=x86 INSTALL_HDR_PATH=/usr 1. How to use it? Given there is a 128M random file a. Read a and record the usage of cache test1.cpp: #include \u003cfcntl.h\u003e #include \u003clinux/mman.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/types.h\u003e #include \u003csyscall.h\u003e #include \u003cunistd.h\u003e // Implement the call interface yourself long sys_cachestat(unsigned int fd, struct cachestat_range *cstat_range, struct cachestat *cstat, unsigned int flags) { return syscall(__NR_cachestat, fd, cstat_range, cstat, flags); } typedef struct { char fn[32]; int fd; FILE *fp; struct cachestat cs; } FNode; int retrieve_cachestat(FNode *n) { struct cachestat_range cr = {0, 1024 * 1024 * 1024}; int r = sys_cachestat(n-\u003efd, \u0026cr, \u0026n-\u003ecs, 0); if (r != 0) perror(\"Failt to call sys_cachestat\\n\"); else { printf(\"File [%s] has %d pages in cache, %d evicted\\n\", n-\u003efn, (int)(n-\u003ecs.nr_cache), (int)(n-\u003ecs.nr_evicted)); } return r; } // Read the file so that the file is written into cache as much as possible void fetch_fileecontent(FNode *n) { FILE *fp = n-\u003efp; char buf[8]; while (1) { if (fread(buf, 1, sizeof(buf), fp) \u003c= 0) break; if (fseek(fp, 4096, SEEK_CUR)) break; } } int openfile(FNode *on) { on-\u003efp = NULL; FILE *fp = fopen(on-\u003efn, \"r\"); if (fp == NULL) return -1; int fd = fileno(fp); on-\u003efd = fd; on-\u003efp = fp; return 0; } void closefile(FNode *on) { if (on-\u003efp) fclose(on-\u003efp); on-\u003efp = NULL; } int main() { struct cachestat cs; FNode fn; sprintf(fn.fn, \"a\"); openfile(\u0026fn); retrieve_cachestat(\u0026fn); fetch_fileecontent(\u0026fn); retrieve_cachestat(\u0026fn); closefile(\u0026fn); return 0; } Output: ❯ ./test1.out File [a] has 0 pages in cache, 0 evicted File [a] has 32768 pages in cache, 0 evicted This means, in the process of reading the file, 32768 cache pages were loaded. We can check the unit page cache size by running: .. code-block:: bash ❯ getconf PAGESIZE 4096 matches our expectation, as (128*1024*1024)/4096 = 32768 2. Problem Now we have 8 random files f1-f8 of 128M, which are read 128 times in a loop: test2.cpp (Just change the main() function) #define MAXN 8 FNode fns[MAXN]; int main() { int i, k; long counter = 0, m; for (k = 0; k \u003c 128; k++) { for (i = 1; i \u003c= MAXN; i++) { sprintf(fns[i].fn, \"f%d\", i); openfile(\u0026fns[i]); } for (i = 1; i \u003c= MAXN; i++) { retrieve_cachestat(\u0026fns[i]); m = fns[i].cs.nr_cache; fetch_fileecontent(\u0026fns[i]); retrieve_cachestat(\u0026fns[i]); counter += fns[i].cs.nr_cache - m; } for (i = 1; i \u003c= MAXN; i++) closefile(\u0026fns[i]); } printf(\"Total %ld pages loaded\\n\", counter); return 0; } Output: With sufficient memory, 7.5 seconds were used. But what if the memory is just not enough? For example, we only have 1G of memory, however, we also need to allocate memory to the system itself. At this time, the new fi","date":"2023-07-14","objectID":"/posts/cachestat-in-kernel-65/:0:0","tags":["kernel","sys_call","linux"],"title":"Cachestat in Kernel-6.5","uri":"/posts/cachestat-in-kernel-65/"},{"categories":["Tutorial"],"content":" Install GTK4 on Windows11 Contents Install GTK4 on Windows11 1. Download and install Msys2 2. Install GTK4 and Mingw-toolchain 3. Setting Path 4. Hello world Summary This is a guide to install and config GTK4 on Windows 11. Note All steps have been tested in Sandbox: Edition Windows 11 Enterprise Version 22H2 OS build 22621.1848 Hint GTK official guide 1. Download and install Msys2 This tutorial uses the default installation path, if you use a custom one, you need to pay attention when setting PATH later Download from here, and install After clicking Finish, the command line interface will pop up. According to the documentation of Msys2, we first install gcc: pacman -S mingw-w64-ucrt-x86_64-gcc Enter(Y) to install Hint Shift+Ins is the shortcut to paste in Msys2 Shell. 2. Install GTK4 and Mingw-toolchain In order to install GTK4, type in the terminal: pacman -S mingw-w64-x86_64-gtk4 To use GNU/make and other tools, type: pacman -S mingw-w64-x86_64-toolchain base-devel Enter until finished. 3. Setting Path Edit System Variable (Follow here) Add Your path to msys2mingw64bin, as default it's C:\\msys64\\mingw64\\bin. Add Your path to msys2usrbin, as default it's C:\\msys64\\usr\\bin. Note Follow the sequence above, as Windows will follow the sequence on PATH table. This will affect our latter input commands pkg-config and mkdir. Given that we need to use make, however, Msys2 will name it as \"mingw32-make.exe\". So we go to the directory we just put in PATH (C:\\msys64\\mingw64\\bin), find the \"mingw32-make.exe\" and rename to \"make.exe\" (or create copy). Now, when we open cmd or powershell, and type make -v, it works! Then, we try pkg-config --cflags --libs gtk4. We expect to have output like this: Hint If not... \"Follow\" this then, open Msys2 shell, run cp -r /mingw64/lib/pkgconfig/* /usr/share/pkgconfig/ to copy \"gtk4.pc\" to the path that pkg-config can find. 4. Hello world Open a new folder, and create a new file called demo.c. We use the demo from GTK: #include \u003cgtk/gtk.h\u003e static void activate(GtkApplication* app, gpointer user_data) { GtkWidget* window; window = gtk_application_window_new(app); gtk_window_set_title(GTK_WINDOW(window), \"Window\"); gtk_window_set_default_size(GTK_WINDOW(window), 200, 200); gtk_widget_show(window); } int main(int argc, char** argv) { GtkApplication* app; int status; app = gtk_application_new(\"org.gtk.example\", G_APPLICATION_DEFAULT_FLAGS); g_signal_connect(app, \"activate\", G_CALLBACK(activate), NULL); status = g_application_run(G_APPLICATION(app), argc, argv); g_object_unref(app); return status; } And another file called makefile: CC = gcc CFLAGS = -O2 -Wall GTK_CFLAGS = `pkg-config --cflags gtk4` GTK_LIBS = `pkg-config --libs gtk4` all: @mkdir -p ./out $(CC) $(GTK_CFLAGS) -o ./out/demo.exe demo.c $(GTK_LIBS) Remember to save them, and open a cmd in this directory (Shift + Right click). Run make, the .exe file will be generated under ./out. (Ignore warning message) Summary That's all the steps, looks like it's hard to config the basic environment for C development. So, life is short, I choose Linux :) ","date":"2023-07-11","objectID":"/posts/install-gtk4-on-windows/:0:0","tags":["GTK4","Msys2","Windows","Installation","GNU/make"],"title":"Install GTK4 on Windows","uri":"/posts/install-gtk4-on-windows/"}]