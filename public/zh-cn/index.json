[{"categories":null,"content":" {.align-center} :::: note ::: title Note ::: 本文系统环境： Linux gentoo 6.5.0-rc1 :::: 如果你想自己尝试，你需要知道的几个命令： 创建随机文件用于测试 : ``` bash #signle random file \"a\" dd if=/dev/urandom of=a bs=1M count=128 # random files \"f1\"-\"f8\" for i in {1..8} do dd if=/dev/urandom of=f${i} bs=1M count=128 done ``` 清除系统cache： root# echo 3 \u003e /proc/sys/vm/drop_caches :::: warning ::: title Warning ::: 在每一次运行测试程序之前都应该清除缓存，因为在生成文件时，它其实已经被写入cache了！同时，在运行过一次程序后，可能会有文件残留的cache :::: #. 限制内存： root# echo 1073741824 \u003e /sys/fs/cgroup/user.slice/memory.max :::: caution ::: title Caution ::: 要解除内存限制千万 不能 将文件改为空或者0， 而应该将内容改为 max :::: :::: note ::: title Note ::: 由于glibc目前还没有支持最新的系统函数调用，这里我们先借用kernel里的函数实现： 安装kernel的头文件， 参考这里 ： # run as root cd /usr/src/linux-6.5-rc1 #where the kernel source is make headers_install ARCH=x86 INSTALL_HDR_PATH=/usr :::: 1. 如何使用？读取一个128M的随机文件a,记录cache的使用情况： test1.cpp: #include \u003cfcntl.h\u003e #include \u003clinux/mman.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/types.h\u003e #include \u003csyscall.h\u003e #include \u003cunistd.h\u003e // 自己来实现调用接口 long sys_cachestat(unsigned int fd, struct cachestat_range *cstat_range, struct cachestat *cstat, unsigned int flags) { return syscall(__NR_cachestat, fd, cstat_range, cstat, flags); } typedef struct { char fn[32]; int fd; FILE *fp; struct cachestat cs; } FNode; int retrieve_cachestat(FNode *n) { struct cachestat_range cr = {0, 1024 * 1024 * 1024}; int r = sys_cachestat(n-\u003efd, \u0026cr, \u0026n-\u003ecs, 0); if (r != 0) perror(\"Failt to call sys_cachestat\\n\"); else { printf(\"File [%s] has %d pages in cache, %d evicted\\n\", n-\u003efn, (int)(n-\u003ecs.nr_cache), (int)(n-\u003ecs.nr_evicted)); } return r; } // 间隔读取文件，使文件尽可能的被写入cache void fetch_fileecontent(FNode *n) { FILE *fp = n-\u003efp; char buf[8]; while (1) { if (fread(buf, 1, sizeof(buf), fp) \u003c= 0) break; if (fseek(fp, 4096, SEEK_CUR)) break; } } int openfile(FNode *on) { on-\u003efp = NULL; FILE *fp = fopen(on-\u003efn, \"r\"); if (fp == NULL) return -1; int fd = fileno(fp); on-\u003efd = fd; on-\u003efp = fp; return 0; } void closefile(FNode *on) { if (on-\u003efp) fclose(on-\u003efp); on-\u003efp = NULL; } int main() { struct cachestat cs; FNode fn; sprintf(fn.fn, \"a\"); openfile(\u0026fn); retrieve_cachestat(\u0026fn); fetch_fileecontent(\u0026fn); retrieve_cachestat(\u0026fn); closefile(\u0026fn); return 0; } 输出： ❯ ./test1.out File [a] has 0 pages in cache, 0 evicted File [a] has 32768 pages in cache, 0 evicted 说明读取文件的过程中，载入了32768个cache pages 查看单位页缓存大小 ❯ getconf PAGESIZE 4096 符合等式： (128*1024*1024)/4096 = 32768 2. 问题场景现在我们有8个128M的随机文件f1-f8，循环打开128次： 只需要修改main()函数 test2.cpp: #define MAXN 8 FNode fns[MAXN]; int main() { int i, k; long counter = 0, m; for (k = 0; k \u003c 128; k++) { for (i = 1; i \u003c= MAXN; i++) { sprintf(fns[i].fn, \"f%d\", i); openfile(\u0026fns[i]); } for (i = 1; i \u003c= MAXN; i++) { retrieve_cachestat(\u0026fns[i]); m = fns[i].cs.nr_cache; fetch_fileecontent(\u0026fns[i]); retrieve_cachestat(\u0026fns[i]); counter += fns[i].cs.nr_cache - m; } for (i = 1; i \u003c= MAXN; i++) closefile(\u0026fns[i]); } printf(\"Total %ld pages loaded\\n\", counter); return 0; } 输出： {.align-center} 在内存足够的情况下，使用了 7.5 秒。 但如果内存刚好不够用呢？比如我们只有1G内存，并且还需要给系统本身分配内存。这时，新的文件（比如f8）就会一直刷新cache（f1-f7的内容）,而一轮循环后，f1又会去抢占别的文件的cache。 这时就会造成巨大的性能损失： 用时 50 秒！ 3.运用cachestat解决问题 这时我们就可以更具cachestat提供的信息，在每一轮新循环时，依据文件在cache中的大小排序读取顺序。 ❯ diff test2.cpp test3.cpp 9a10 \u003e using std::sort; 60c61,65 \u003c FNode fns[MAXN]; --- \u003e FNode fns[MAXN+4]; \u003e int ix[MAXN+4]; \u003e bool mycmp(int a,int b){ \u003e return fns[a].cs.nr_cache\u003efns[b].cs.nr_cache; \u003e } 70a76,80 \u003e ix[i-1]=i; \u003e } \u003e sort(ix,ix+MAXN,mycmp); \u003e for(int j=0;j\u003cMAXN;j++){ \u003e i=ix[j]; 完整文件： test3.cpp: #include \u003cfcntl.h\u003e #include \u003clinux/mman.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/types.h\u003e #include \u003csyscall.h\u003e #include \u003cunistd.h\u003e #include \u003calgorithm\u003e using std::sort; long sys_cachestat(unsigned int fd, struct cachestat_range *cstat_range, struct cachestat *cstat, unsigned int flags) { return syscall(__NR_cachestat, fd, cstat_range, cstat, flags); } typedef struct { char fn[32]; int fd; FILE *fp; struct cachestat cs; } FNode; int retrie","date":"0001-01-01","objectID":"/zh-cn/posts/cachestat-in-kernel-65-rc1/:0:0","tags":["kernel","sys_call","linux"],"title":"初探cachestat接口------kernel 6.5-rc1","uri":"/zh-cn/posts/cachestat-in-kernel-65-rc1/"},{"categories":null,"content":"一个关于在Win 11上使用Msys2安装Gtk4,并且使用makefile生成一个Hello\nworld的demo的指北\n","date":"0001-01-01","objectID":"/zh-cn/posts/install-gtk4-on-windows/","tags":["GTK4","Msys2","Windows","Installation","GNU/make"],"title":"在Windows 11上安装GTK4","uri":"/zh-cn/posts/install-gtk4-on-windows/"},{"categories":null,"content":"{.gtk .gtkalign-center} 在Win11上安装GTK4::: contents ::: 一个关于在Win 11上使用Msys2安装Gtk4,并且使用makefile生成一个Hello world的demo的指北 并且包括了作者在安装过程中遇到的坑... 安装过程在的Sandbox里经过测试: :::: note ::: title Note ::: Edition Windows 11 Enterprise Version 22H2 OS build 22621.1848 :::: :::: hint ::: title Hint ::: GTK官网的安装指南 :::: ","date":"0001-01-01","objectID":"/zh-cn/posts/install-gtk4-on-windows/:0:0","tags":["GTK4","Msys2","Windows","Installation","GNU/make"],"title":"在Windows 11上安装GTK4","uri":"/zh-cn/posts/install-gtk4-on-windows/"},{"categories":null,"content":" 安装过程","date":"0001-01-01","objectID":"/zh-cn/posts/install-gtk4-on-windows/:1:0","tags":["GTK4","Msys2","Windows","Installation","GNU/make"],"title":"在Windows 11上安装GTK4","uri":"/zh-cn/posts/install-gtk4-on-windows/"},{"categories":null,"content":" 1. 下载并安装Msys2本教程使用默认安装路径，如使用自定义，在后文设置PATH时需要注意 从官网下载 Msys2，并安装 点击Finish后弹出命令行界面，根据Msys2的文档，我们首先安装gcc :::: note ::: title Note ::: 国内用户可能需要更换国内源提升下载速度， 这里我们使用 清华大学镜像站 ,在终端输入 sed -i \"s#https\\?://mirror.msys2.org/#https://mirrors.tuna.tsinghua.edu.cn/msys2/#g\" /etc/pacman.d/mirrorlist* 完成换源 :::: pacman -S mingw-w64-ucrt-x86_64-gcc {.align-center} 回车开始安装 :::: hint ::: title Hint ::: 在Msys2 Shell里的复制可以快捷键Shift+Ins :::: ","date":"0001-01-01","objectID":"/zh-cn/posts/install-gtk4-on-windows/:1:1","tags":["GTK4","Msys2","Windows","Installation","GNU/make"],"title":"在Windows 11上安装GTK4","uri":"/zh-cn/posts/install-gtk4-on-windows/"},{"categories":null,"content":" 2. 安装GTK4库和toolchain要安装GTK4，在终端输入 pacman -S mingw-w64-x86_64-gtk4 为了在windows上使用GNU/make，输入 pacman -S mingw-w64-x86_64-toolchain base-devel 都是一路回车选择默认 {.align-center} ","date":"0001-01-01","objectID":"/zh-cn/posts/install-gtk4-on-windows/:1:2","tags":["GTK4","Msys2","Windows","Installation","GNU/make"],"title":"在Windows 11上安装GTK4","uri":"/zh-cn/posts/install-gtk4-on-windows/"},{"categories":null,"content":" 3. 设置Path打开 Path设置 细节不赘述 在系统变量里找到Path,打开后加上你的安装路径 mingw64bin ，（对我来说就是 C:\\msys64\\mingw64\\bin ） 再新建一个 C:\\msys64\\usr\\bin，点击确定保存。 :::: note ::: title Note ::: 这里千万要注意顺序，因为Windows会依照PATH从前到后扫描。这对之后的 pkg-config 以及 mkdir 都有影响 :::: 由于我们要使用 make 命令,而Msys2默认把它命名为\"mingw32-make\"。所以我们进入刚刚输入的目录（C:/msys64/mingw64/bin），找到 mingw32-make 重命名（或者ctrl+c,ctrl+v生成一个副本），命名为make。 此时我们再打开cmd(Win+R)，输入 make -v ,发现已经可以运行了。 接着再在cmd中试一下命令 pkg-config --cflags --libs gtk4 ，如果有类似下面的输出，就说明成功了： {.align-center} :::: hint ::: title Hint ::: 如果没有，那么可以说你不幸遇到了第一个坑,和作者一样（ 首先给MS扣 666 （菜 打开Msys2 Shell，运行 cp -r /mingw64/lib/pkgconfig/* /usr/share/pkgconfig/ 这就会把它提示的\"gtk4.pc\"以及其他一系列依赖，复制到 pkg-config 会自动扫描的文件夹下。 :::: ","date":"0001-01-01","objectID":"/zh-cn/posts/install-gtk4-on-windows/:1:3","tags":["GTK4","Msys2","Windows","Installation","GNU/make"],"title":"在Windows 11上安装GTK4","uri":"/zh-cn/posts/install-gtk4-on-windows/"},{"categories":null,"content":" 4. Hello World新建一个文件夹，这里就叫demo,在里面创建demo.c (Shift+右键文件资源管理器，在该目录下打开powershell，输入 notepad demo.c ) 这里使用GTK官方的实例： #include \u003cgtk/gtk.h\u003e static void activate(GtkApplication* app, gpointer user_data) { GtkWidget* window; window = gtk_application_window_new(app); gtk_window_set_title(GTK_WINDOW(window), \"Window\"); gtk_window_set_default_size(GTK_WINDOW(window), 200, 200); gtk_widget_show(window); } int main(int argc, char** argv) { GtkApplication* app; int status; app = gtk_application_new(\"org.gtk.example\", G_APPLICATION_DEFAULT_FLAGS); g_signal_connect(app, \"activate\", G_CALLBACK(activate), NULL); status = g_application_run(G_APPLICATION(app), argc, argv); g_object_unref(app); return status; } 保存后回到命令行，再创建一个名为 makefile 的文件，输入以下内容： CC = gcc CFLAGS = -O2 -Wall GTK_CFLAGS = `pkg-config --cflags gtk4` GTK_LIBS = `pkg-config --libs gtk4` all: @mkdir -p ./out $(CC) $(GTK_CFLAGS) -o ./out/demo.exe demo.c $(GTK_LIBS) :::: note ::: title Note ::: 这里的 mkdir 又是一个坑，安装Msys2后，在 usr/bin 下会有一个mkdir.exe，它是从linux移植来的，支持linux的一些参数。而powersehll的mkdir则 不支持参数 。所以我们将 C:msys64usrbin 加入Path。 但这可能又会造成一些问题，比如在 usr/bin 目录下可能会有 python.exe ，这就可能会影响你使用 pip 安装。所以，PATH的顺序很重要，你可以将python的 /bin 目录放在最上面。 :::: 保存后运行 make 命令，exe文件就会再 ./out 文件夹下生成。 {.align-center} ","date":"0001-01-01","objectID":"/zh-cn/posts/install-gtk4-on-windows/:1:4","tags":["GTK4","Msys2","Windows","Installation","GNU/make"],"title":"在Windows 11上安装GTK4","uri":"/zh-cn/posts/install-gtk4-on-windows/"},{"categories":null,"content":" 总结到这里，安装已经基本结束了。可以发现在Windows下安装配置C语言的环境相比Linux来说，体验上差很多。 所以在这里推荐大家使用Gentoo，并使用 emerge -a gui-libs/gtk 终结本文（ 如果还有其他问题，欢迎在此讨论，有能力者自行Google(Baidu)。 至于使用 Vcpkg 安装以及对 Vistual Studio 的支持，以后会再补充。 ","date":"0001-01-01","objectID":"/zh-cn/posts/install-gtk4-on-windows/:2:0","tags":["GTK4","Msys2","Windows","Installation","GNU/make"],"title":"在Windows 11上安装GTK4","uri":"/zh-cn/posts/install-gtk4-on-windows/"}]