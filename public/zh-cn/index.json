[{"categories":["Review"],"content":"注：标题所指的xv6是MIT的计算机操作系统课程S.081。 ","date":"2024-06-16","objectID":"/zh-cn/posts/2296229/:0:0","tags":["Linux","Debug"],"title":"xv6学习笔记","uri":"/zh-cn/posts/2296229/"},{"categories":["Review"],"content":" LEC 1: util 环境部署上来就在环境部署上遇到了点小问题，虽然别人不太可能遇到，但仍记录在此，仅作参考。 我用的是Gentoo Linux，通过crossdev编译出的riscv64-unkown-linux-gnu是不可用的，个人猜测是因为它链接了Linux的一些库，而xv6是裸二进制的elf环境。（对于toolchain并不熟悉，欢迎指正）。 Gentoo官方配置编译出的qemu对于xv6也是不可用的状态,没有任何输出（QEMU_SOFTMMU_TARGETS=“riscv64”），可能是版本太高了导致不兼容… 2024.7.4更新： 关于qemu没有输出的问题，可以换用2023版的xv6(git clone git://g.csail.mit.edu/xv6-labs-2023)。 二者的解决方案是一样的，就是按照课程的教程下载编译安装对应的软件。安装位置可以选在/opt,最后在.[zsh,bash]rc里加上:export PATH=\"/opt/qemu/bin:/opt/riscv-gcc/bin:%PATH\" xargs.c一开使有一个小问题没注意到，xv6要求的xargs是将每一行的输入都与argv单独合并。 比如，假设xv6的echo支持转义符，echo \"hello\\nworld\" | xargs echo print:，应该打印出两行两个print:，而非两行一个print: 所以最后执行exec的时候，应该维护一个*xargv[],将argv[1:]与stdin的一行输入进行合并。 同时，应该注意到read()读取到\\n的时候应该在字符串末尾写入\\0而非\\n。 primes.c这个程序难就难在debug环节上，很难仅靠程序本身打印log的方式纠错。我的解决方案是替换掉头文件(unistd.h)然后在本地环境下编译调试。 需要注意到如果在父进程中关闭了管道(pipe)，管道里的缓存会被同时清空。所以父进程可以在输出完后再写入一个0(EOF)，并交由子进程关闭管道。 在编写的时候不宜过早优化，可以在确定算法正确性后再优化管道数使用的问题。可以用一个栈(stack)来管理可用的管道，至于要不要给栈上锁，我觉得在这个例子里是不需要的：唯一的问题就是栈可能为空。 ","date":"2024-06-16","objectID":"/zh-cn/posts/2296229/:0:1","tags":["Linux","Debug"],"title":"xv6学习笔记","uri":"/zh-cn/posts/2296229/"},{"categories":["Review"],"content":" LEC 2: syscall trace这题本身不难，只要想到用类似p-\u003emask \u0026 1 \u003c\u003c num来判定flag，就解决了一半。 依照“没有困难，创造困难也要上”的最高指示，所有的编译环境是部署在Thinkpad T61上——一个年过15的老同志上。它来处理一个虚拟内存只有128M的虚拟机是绰绰有余的，但是问题出在这道题的测试样例上: // user/usertests.c:917 void forkforkfork(char *s) { ... while(1){ int fd = open(\"stopforking\", 0); if(fd \u003e= 0){ exit(0); } if(fork() \u003c 0){ close(open(\"stopforking\", O_CREATE|O_RDWR)); } } ... wait(0); ... } 由于fork()本身的特性，它的返回时间依赖它的所有子进程。所以在通过了所有其他测试样例的大前提下，这个测试却没有任何输出： 在继约半小时撸码后的两个小时debug时间里，一度怀疑人生。 最后发现bug在电脑上，所有fork()执行完需要5min，而测试的时限是30s… 换成7900x跑了一下只要1.3s… ","date":"2024-06-16","objectID":"/zh-cn/posts/2296229/:0:2","tags":["Linux","Debug"],"title":"xv6学习笔记","uri":"/zh-cn/posts/2296229/"},{"categories":["Review"],"content":" LEC 4: pgtbl这里的三道题都要求你看懂与其相关的大部分函数，也或多或少都是可以通过魔改现有函数来解题的。 比如copyin里，要在exec()里将对进程页表的修改同时也映射到私有的内核页表里。直接修改uvmalloc()应该也是可行的， 但是也可以借鉴一下uvmcopy()来一次性的映射所有内存。 题目有的指示比较隐晦，比如You’ll need a way to free a page table without also freeing the leaf physical memory pages 看上去似乎要找出什么小trick，但实际上只要看一眼freewalk()的代码就明白了。 ","date":"2024-06-16","objectID":"/zh-cn/posts/2296229/:0:3","tags":["Linux","Debug"],"title":"xv6学习笔记","uri":"/zh-cn/posts/2296229/"},{"categories":["Review"],"content":" LEC 8 lazy:题目相对比较简单，也是因为主要思路和代码已经在课上给出。 但还有一些小坑：第三问第四小条—— Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated. 简单阅读源代码后可以定位到syscall.c里的argaddr()函数，简单的复制trap.c里的修改是通过不了validatetest的。 首先需要调用walkaddr函数验证*ip是否已经分配过了。然后很重要的一点来了： 如果地址不合法，p-\u003ekilled = 1并不会像在usertrap()里那样使进程正确的退出，应直接return -1交由对应的SYS_*函数处理。 ","date":"2024-06-16","objectID":"/zh-cn/posts/2296229/:0:4","tags":["Linux","Debug"],"title":"xv6学习笔记","uri":"/zh-cn/posts/2296229/"},{"categories":["Review"],"content":" LEC 10 COW:这个lab是我目前花时间最多的一个，比pgtbl还多。原因有几个，题目给的提示比较少，至少相对于它的难度而言； 再有我个人的问题，前期急于验证程序的正确性而到处添加修改，存有侥幸心理，忽略了这题可以将函数解耦从而简化调试。 一开始开了一个ref_count[PHYSTOP/PGSIZE]的大数组用来引用计数，然后想着全部初始化为0会方便一些，结果有些页总是会被提前释放。 之后改成了初始化为1，父进程的引用也算一次，逻辑上也更说得通。 最麻烦的是要通过usertests，很多组测试都会在memmove上触发kerneltrap。用gdb看了一下，参数src，和dst都会出现为0的情况， 说明复制COW页面的时候缺少了检查pa和va的步骤。这些条件在usertrap()和copyout()里都要用到。 这里也发现了一个使用gdb调试的小技巧——要想跳转到memmove在内核崩溃前的最后一次（接近）执行，可以先加载用户程序的符号，在测试函数那里断下。再加载内核符号，在memmove断下，这样就不用一步一步跳转了。 ","date":"2024-06-16","objectID":"/zh-cn/posts/2296229/:0:5","tags":["Linux","Debug"],"title":"xv6学习笔记","uri":"/zh-cn/posts/2296229/"},{"categories":["Review"],"content":" LEC 11 thread:这一个lab比较简单，唯一一个卡住的点在第一题。在thread_create()里忘记了栈是向上增长的，把寄存器sp直接指向了t-\u003estack。 这里导致了一个很有意思的结果，uthread只会运行c的循环，输出类似于： $ uthread thread_a started thread_b started thread_c started thread_c 0 thread_c 1 thread_c 2 ... thread_c 99 thread_c: exit after 100 thread_schedule: no runnable threads $ 这是因为stack在向下生长的时候把内存里相邻的上一个thread结构体改写了，其中的state如果被改写成别的，那么thread_schedule就可能永远不会切换到它。 ","date":"2024-06-16","objectID":"/zh-cn/posts/2296229/:0:6","tags":["Linux","Debug"],"title":"xv6学习笔记","uri":"/zh-cn/posts/2296229/"},{"categories":["Review"],"content":" To be continue…","date":"2024-06-16","objectID":"/zh-cn/posts/2296229/:0:7","tags":["Linux","Debug"],"title":"xv6学习笔记","uri":"/zh-cn/posts/2296229/"},{"categories":["Review"],"content":" Note 本文系统环境： Linux gentoo 6.5.0-rc1 如果你想自己尝试，你需要知道的几个命令： 创建随机文件用于测试 #signle random file \"a\" dd if=/dev/urandom of=a bs=1M count=128 # random files \"f1\"-\"f8\" for i in {1..8} do dd if=/dev/urandom of=f${i} bs=1M count=128 done 清除系统cache： root# echo 3 \u003e /proc/sys/vm/drop_caches Warning 在每一次运行测试程序之前都应该清除缓存，因为在生成文件时，它其实已经被写入cache了！同时，在运行过一次程序后，可能会有文件残留的cache 限制内存： root# echo 1073741824 \u003e /sys/fs/cgroup/user.slice/memory.max Caution! 要解除内存限制千万 不能 将文件改为空或者0， 而应该将内容改为 max Note 由于glibc目前还没有支持最新的系统函数调用，这里我们先借用kernel里的函数实现： 安装kernel的头文件， 参考这里 ： # run as root cd /usr/src/linux-6.5-rc1 #where the kernel source is make headers_install ARCH=x86 INSTALL_HDR_PATH=/usr 1. 如何使用？ 读取一个128M的随机文件a,记录cache的使用情况： test1.cpp: #include \u003cfcntl.h\u003e #include \u003clinux/mman.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/types.h\u003e #include \u003csyscall.h\u003e #include \u003cunistd.h\u003e // 自己来实现调用接口 long sys_cachestat(unsigned int fd, struct cachestat_range *cstat_range, struct cachestat *cstat, unsigned int flags) { return syscall(__NR_cachestat, fd, cstat_range, cstat, flags); } typedef struct { char fn[32]; int fd; FILE *fp; struct cachestat cs; } FNode; int retrieve_cachestat(FNode *n) { struct cachestat_range cr = {0, 1024 * 1024 * 1024}; int r = sys_cachestat(n-\u003efd, \u0026cr, \u0026n-\u003ecs, 0); if (r != 0) perror(\"Failt to call sys_cachestat\\n\"); else { printf(\"File [%s] has %d pages in cache, %d evicted\\n\", n-\u003efn, (int)(n-\u003ecs.nr_cache), (int)(n-\u003ecs.nr_evicted)); } return r; } // 间隔读取文件，使文件尽可能的被写入cache void fetch_fileecontent(FNode *n) { FILE *fp = n-\u003efp; char buf[8]; while (1) { if (fread(buf, 1, sizeof(buf), fp) \u003c= 0) break; if (fseek(fp, 4096, SEEK_CUR)) break; } } int openfile(FNode *on) { on-\u003efp = NULL; FILE *fp = fopen(on-\u003efn, \"r\"); if (fp == NULL) return -1; int fd = fileno(fp); on-\u003efd = fd; on-\u003efp = fp; return 0; } void closefile(FNode *on) { if (on-\u003efp) fclose(on-\u003efp); on-\u003efp = NULL; } int main() { struct cachestat cs; FNode fn; sprintf(fn.fn, \"a\"); openfile(\u0026fn); retrieve_cachestat(\u0026fn); fetch_fileecontent(\u0026fn); retrieve_cachestat(\u0026fn); closefile(\u0026fn); return 0; } 输出： ❯ ./test1.out File [a] has 0 pages in cache, 0 evicted File [a] has 32768 pages in cache, 0 evicted 说明读取文件的过程中，载入了32768个cache pages 查看单位页缓存大小 ❯ getconf PAGESIZE 4096 符合等式： (128*1024*1024)/4096 = 32768 2. 问题场景 现在我们有8个128M的随机文件f1-f8，循环打开128次： 只需要修改main()函数 test2.cpp: #define MAXN 8 FNode fns[MAXN]; int main() { int i, k; long counter = 0, m; for (k = 0; k \u003c 128; k++) { for (i = 1; i \u003c= MAXN; i++) { sprintf(fns[i].fn, \"f%d\", i); openfile(\u0026fns[i]); } for (i = 1; i \u003c= MAXN; i++) { retrieve_cachestat(\u0026fns[i]); m = fns[i].cs.nr_cache; fetch_fileecontent(\u0026fns[i]); retrieve_cachestat(\u0026fns[i]); counter += fns[i].cs.nr_cache - m; } for (i = 1; i \u003c= MAXN; i++) closefile(\u0026fns[i]); } printf(\"Total %ld pages loaded\\n\", counter); return 0; } 输出： 在内存足够的情况下，使用了 7.5 秒。 但如果内存刚好不够用呢？比如我们只有1G内存，并且还需要给系统本身分配内存。这时，新的文件（比如f8）就会一直刷新cache（f1-f7的内容）,而一轮循环后，f1又会去抢占别的文件的cache。 这时就会造成巨大的性能损失： 用时 50 秒！ 3.运用cachestat解决问题 这时我们就可以更具cachestat提供的信息，在每一轮新循环时，依据文件在cache中的大小排序读取顺序。 ❯ diff test2.cpp test3.cpp 9a10 \u003e using std::sort; 60c61,65 \u003c FNode fns[MAXN]; --- \u003e FNode fns[MAXN+4]; \u003e int ix[MAXN+4]; \u003e bool mycmp(int a,int b){ \u003e return fns[a].cs.nr_cache\u003efns[b].cs.nr_cache; \u003e } 70a76,80 \u003e ix[i-1]=i; \u003e } \u003e sort(ix,ix+MAXN,mycmp); \u003e for(int j=0;j\u003cMAXN;j++){ \u003e i=ix[j]; 完整文件： test3.cpp: #include \u003cfcntl.h\u003e #include \u003clinux/mman.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/types.h\u003e #include \u003csyscall.h\u003e #include \u003cunistd.h\u003e #include \u003calgorithm\u003e using std::sort; long sys_cachestat(unsigned int fd, struct cachestat_range *cstat_range, struct cachestat *cstat, unsigned int flags) { return syscall(__NR_cachestat, fd, cstat_range, cstat, flags); } typedef struct { char fn[32]; int fd; FILE *fp; struct cachestat cs; } FNode; int retrieve_cachestat(FNode *n) { struct cachestat_range cr = {0, 1024 * 1024 * 1024}; int r = sys_cachestat(n-\u003efd, \u0026cr, \u0026n-\u003ecs, 0); if (r != 0) perror(\"Failt to call sys_cachest","date":"2023-07-14","objectID":"/zh-cn/posts/cachestat-in-kernel-65/:0:0","tags":["kernel","sys_call","linux"],"title":"浅析Kernel-6.5新系统调用","uri":"/zh-cn/posts/cachestat-in-kernel-65/"},{"categories":["Tutorial"],"content":"一个关于在Win 11上使用Msys2安装Gtk4,并且使用makefile生成一个Hello world的demo的指北","date":"2023-07-11","objectID":"/zh-cn/posts/install-gtk4-on-windows/","tags":["GTK4","Msys2","Windows","Installation","GNU/make"],"title":"在Windows上安装Gtk4","uri":"/zh-cn/posts/install-gtk4-on-windows/"},{"categories":["Tutorial"],"content":" 在Win11上安装GTK4 Contents 在Win11上安装GTK4 安装过程 1. 下载并安装Msys2 2. 安装GTK4库和toolchain 3. 设置Path 4. Hello World 总结 一个关于在Win 11上使用Msys2安装Gtk4,并且使用makefile生成一个Hello world的demo的指北 并且包括了作者在安装过程中遇到的坑... 安装过程在的Sandbox里经过测试: Note Edition Windows 11 Enterprise Version 22H2 OS build 22621.1848 Hint GTK官网的安装指南 安装过程 1. 下载并安装Msys2 本教程使用默认安装路径，如使用自定义，在后文设置PATH时需要注意 从官网下载 Msys2，并安装 点击Finish后弹出命令行界面，根据Msys2的文档，我们首先安装gcc Note 国内用户可能需要更换国内源提升下载速度， 这里我们使用 清华大学镜像站 ,在终端输入 sed -i \"s#https\\?://mirror.msys2.org/#https://mirrors.tuna.tsinghua.edu.cn/msys2/#g\" /etc/pacman.d/mirrorlist* 完成换源 pacman -S mingw-w64-ucrt-x86_64-gcc 回车开始安装 Hint 在Msys2 Shell里的复制可以快捷键Shift+Ins 2. 安装GTK4库和toolchain 要安装GTK4，在终端输入 pacman -S mingw-w64-x86_64-gtk4 为了在windows上使用GNU/make，输入 pacman -S mingw-w64-x86_64-toolchain base-devel 都是一路回车选择默认 3. 设置Path 打开 Path设置 细节不赘述 在系统变量里找到Path,打开后加上你的安装路径 mingw64bin ，（对我来说就是 C:\\msys64\\mingw64\\bin ） 再新建一个 C:\\msys64\\usr\\bin，点击确定保存。 Note 这里千万要注意顺序，因为Windows会依照PATH从前到后扫描。这对之后的 pkg-config 以及 mkdir 都有影响 由于我们要使用 make 命令,而Msys2默认把它命名为\"mingw32-make\"。所以我们进入刚刚输入的目录（C:/msys64/mingw64/bin），找到 mingw32-make 重命名（或者ctrl+c,ctrl+v生成一个副本），命名为make。 此时我们再打开cmd(Win+R)，输入 make -v ,发现已经可以运行了。 接着再在cmd中试一下命令 pkg-config --cflags --libs gtk4 ，如果有类似下面的输出，就说明成功了： Hint 如果没有，那么可以说你不幸遇到了第一个坑,和作者一样（ 首先给MS扣 666 （菜 打开Msys2 Shell，运行 cp -r /mingw64/lib/pkgconfig/* /usr/share/pkgconfig/ 这就会把它提示的\"gtk4.pc\"以及其他一系列依赖，复制到 pkg-config 会自动扫描的文件夹下。 4. Hello World 新建一个文件夹，这里就叫demo,在里面创建demo.c (Shift+右键文件资源管理器，在该目录下打开powershell，输入 notepad demo.c ) 这里使用GTK官方的实例： #include \u003cgtk/gtk.h\u003e static void activate(GtkApplication* app, gpointer user_data) { GtkWidget* window; window = gtk_application_window_new(app); gtk_window_set_title(GTK_WINDOW(window), \"Window\"); gtk_window_set_default_size(GTK_WINDOW(window), 200, 200); gtk_widget_show(window); } int main(int argc, char** argv) { GtkApplication* app; int status; app = gtk_application_new(\"org.gtk.example\", G_APPLICATION_DEFAULT_FLAGS); g_signal_connect(app, \"activate\", G_CALLBACK(activate), NULL); status = g_application_run(G_APPLICATION(app), argc, argv); g_object_unref(app); return status; } 保存后回到命令行，再创建一个名为 makefile 的文件，输入以下内容： CC = gcc CFLAGS = -O2 -Wall GTK_CFLAGS = `pkg-config --cflags gtk4` GTK_LIBS = `pkg-config --libs gtk4` all: @mkdir -p ./out $(CC) $(GTK_CFLAGS) -o ./out/demo.exe demo.c $(GTK_LIBS) Note 这里的 mkdir 又是一个坑，安装Msys2后，在 usr/bin 下会有一个mkdir.exe，它是从linux移植来的，支持linux的一些参数。而powersehll的mkdir则 不支持参数 。所以我们将 C:msys64usrbin 加入Path。 但这可能又会造成一些问题，比如在 usr/bin 目录下可能会有 python.exe ，这就可能会影响你使用 pip 安装。所以，PATH的顺序很重要，你可以将python的 /bin 目录放在最上面。 保存后运行 make 命令，exe文件就会再 ./out 文件夹下生成。 总结 到这里，安装已经基本结束了。可以发现在Windows下安装配置C语言的环境相比Linux来说，体验上差很多。 所以在这里推荐大家使用Gentoo，并使用 emerge -a gui-libs/gtk 终结本文（ 如果还有其他问题，欢迎在此讨论，有能力者自行Google(Baidu)。 至于使用 Vcpkg 安装以及对 Vistual Studio 的支持，以后会再补充。 ","date":"2023-07-11","objectID":"/zh-cn/posts/install-gtk4-on-windows/:0:0","tags":["GTK4","Msys2","Windows","Installation","GNU/make"],"title":"在Windows上安装Gtk4","uri":"/zh-cn/posts/install-gtk4-on-windows/"}]